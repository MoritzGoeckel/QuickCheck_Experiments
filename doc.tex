% RUN pdflatex doc
% RUN biber doc
% RUN pdflatex doc
% PROFIT!

\documentclass[a4paper, 12pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\usepackage{filecontents}

\usepackage[latin1]{inputenc}

\usepackage{biblatex}
\addbibresource{doc.bib}

\usepackage[protrusion=tr\"u,expansion=tr\"u]{microtype} % Better typography
\usepackage{graphicx} % Required for including pictures
\usepackage{wrapfig} % Allows in-line images

\usepackage{mathpazo} % Use the Palatino font
%\usepackage[T1]{fontenc} % Required for accented characters
\linespread{1.50} % Change line spacing here, Palatino benefits from a slight increase by default

\usepackage{minted} %Syntax highlighting
\usepackage{etoolbox} %Change minted line spacing
\AtBeginEnvironment{minted}{\singlespacing%
    \fontsize{10}{10}\selectfont}

\makeatletter
%\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
%\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography

\renewcommand{\maketitle}{ 
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author}
\\\@date 

\vspace{40pt}
\end{flushright}
}

\title{\textbf{QuickCheck}\\ % Title
A tool for random testing} % Subtitle

\author{\textsc{Moritz G\"ockel} % Author
\\{\textit{Hochschule Karlsruhe Technik und Wirtschaft}}} % Institution

\date{\today}

\begin{document}

\maketitle

\vspace{30pt}

\newpage
\tableofcontents
\newpage

\section{Abstract}

\section{Introduction}
\subsection{The problem with testing}

Testing is the primary method to evaluate the correctness of software today. \cite{Ammann2016} Even though exhaustive testing is possible in many cases and majority of bugs can be triggered by relatively few test cases, \cite{Kuhn2004} the required effort to find these test cases can be high. In practice the time spend writing code is not seldom matched by the time spend on finding bugs and creating tests.

The problem that arises with testing is that the amount of required test cases for a good coverage of a software system is rising exponentially as the system becomes larger and more complex. Imagine for example a software with n features. To test each feature individually, one would need at least n test cases. This is still feasible. But in most systems the features interact with each other. This leads to the necessity to also test every feature in cooperation with every other feature. Testing these pairs of features requires us to write therefore an additional $n^2$  new test cases. This thought experiment can be continued with three interacting features, ergo $n^3$ necessary test cases and so forth. \cite{Hughes2016}

We find that in very large complex systems it is often no longer feasible to gain good test coverage by writing test cases manually. Another way of testing needs to be found. 

\subsection{Random test generation}

One way evaluate a softwares correctness is to keep and eye on irregularities while manually testing it. This way is very time consuming as every test case has to be conducted by a person. It can take months to test a big software system this way. Because of this human element, manual testing is also very error prone and therefore not reliable. As an addition to manual testing automated testing has beed widely adopted in the industry. With automated testing bigger test coverage can be achieved and a test runs can be conducted within minutes or hours instead of the months it would take to manually test the software. Unfortunately the testing process is still one of the most expensive parts of software development, even with automated testing. Not seldom the testing efforts account for about half of the development costs. \cite{Claessen2000} The logical next step to reduce these costs after automated testing is the automated generation of test cases. The utilization of automated generation of test cases may lead to further reduced testing effort or the possibility to gain more test coverage in less time.

\section{Theory}

The most expensive part of software testing is not to run or to evaluate them, most of the time the most expensive part is writing the test cases. QuickCheck tackles that problem by letting the software developer write generalized test functions of which each covers many test cases. These generalized test functions in QuickCheck are called properties. \cite{Hughes2010} Because of this generalized approach it is not necessary to write more than one property for each logical property of the to be tested function as many different test cases will be generated anyway. \cite{Hughes2006}

\subsection{Properties}

A property is defined as a function that takes some random test data, provides that test data to the to be tested function and determines afterword whether a general rule about the relation between the random input and the to be tested functions output holds.

\subsubsection{Defining a property}

For example imagine we want to test the "sum" function. We know that the sum of the elements in an array is always the same, no matter the order of the array. We can formulate this kind of logical assertion as a property in Haskell:

\begin{minted}{haskell}
prop_sumRev :: [Int] -> Bool
prop_sumRev xs = 
    sum xs == sum (reverse xs)
\end{minted}

Now we can use QuickCheck to validate whether or not this statement about the sum function holds:

\begin{minted}{haskell}
quickCheck prop_sumRev
-- OK, passed 100 tests.
\end{minted}

QuickCheck generates a set of inputs for the provided function, in this case arrays of Int. QuickCheck may be able to infer the type of the to be generated parameters, but it is good practice to define the type explicitly. That way it is also certain that the generated input is of type [Int] and not [Double] for example. The property holds if the function always returns true for every generated test case. \cite{Claessen2000} Here QuickCheck generated 100 test cases which all yielded true, it can therefore be assumed that the property holds.

\subsubsection{Conditional properties}

Many logical properties only hold under certain conditions. Fortunately QuickCheck provides a concise way to define such an conditional property:

\begin{minted}{haskell}
prop_positivePlusOne :: Int -> Property
prop_positivePlusOne x = 
    x > 0 ==> x + 1 > 0

quickCheck prop_positivePlusOne  
-- OK, passed 100 tests; 110 discarded.
\end{minted}

This property basically states that if x is positive then (x + 1) is also positive. The ==> operator asserts that only if the left side is true, the right side needs to be true as well. \cite{Claessen2000} Not all test cases are relevant to the test outcome when using this operator. In this example all test cases with x being zero or negative do not contribute to the result and are therefore discarded. That is why QuickCheck actually had to run 210 tests to find 100 valid ones.  

\subsubsection{Classify \& Collect}

As seen in the previous example, it is sometimes important to have some information about the generated input data to evaluate how reliable the test actually was. To get more insights into the test cases QuickCheck provides us the functions "classify" and "collect". \cite{Claessen2000} Here an example:

\begin{minted}{haskell}
prop_sumRev :: [Int] -> Property
prop_sumRev xs = 
    classify (null xs || xs == []) "Array empty" \$
    sum xs == sum (reverse xs)

quickCheck prop_sumRev
-- OK, passed 100 tests (7\% Array empty).
\end{minted}

As we can see in the output, 7 of the 100 test cases have been conducted with either null or an empty array. This value changes from test run to test run because the generation of input data is random. It might be useful to know these things as these kinds of tests do not really test the sum function like intendet. Now lets look at "collect":

\begin{minted}{haskell}
prop_sumRev :: [Int] -> Property
prop_sumRev xs = 
    collect (length xs) \$
    sum xs == sum (reverse xs)

quickCheck prop_sumRev
-- OK, passed 100 tests:
--  6\% 2 
--  4\% 0 
--  4\% 1 
--  4\% 11 
-- ... 
--  1\% 86 
\end{minted}

The output shows the distribution of data that has been passed to the "collect" function. In this case one gets insights on the distribution of the array lengths. Six percent of the arrays have been of length 2 followed by 4\% of the length zero.

Note that because the output of QuickCheck contains more information about the test runs when using "classify" or "collect" the return type "Property" has to be used. The return type "Bool" can only encode whether or not the test passed and is therefore no longer valid when using these functions. 

\subsubsection{Infinite data structures}

As QuickCheck was initially implemented in Haskell and Haskell supports infinite data structures, therefore QuickCheck also in theory enables developers to test infinte data structures. Because infinite data structures are only feasable with lazy evaluation and can never be fully evaluated, they of course can also never be fully tested. QuickCheck solves this problem by making the assumption that if a finite ammount of elements of an infinte data structure are valid, then the entire data structure is valid. So the solution in practice is to just convert an infinite data structure into a finite one by taking n elements and then evaluating the correctness of the fininte data structure. The number n is thereby also randomly generated by QuickCheck. If the rule holds for the finite data structure we assume that it also holds for the infinte one. \cite{Claessen2000}

\subsection{Generators}

To generate a concrete test case from a general property some varying input data is required to pass to the to be tested function. This input data is generated randomly in QuickCheck. Even though it might be surprising, it turns out that this random approach competes quite well with systematic methods in practice. \cite{Claessen2000}

QuickCheck has no heuristics or assumptions about the possible input data, it is therefore the task of the user to define its structure. This can be done by implementing generators. This enables the user to define the distribution of the test data to model the expected real world input as close as possible.


\subsubsection{Basic generators \& forAll}

QuickCheck provides a wide variaty of combinable generators which can be used very effectively to model the randomly choosen input data. One of these generators is "choose" which provided two arguments returns a random value between them. This can be used to optimize the previous example "prop\_positivePlusOne" by generating only positive input data in the first place. That way we avoid generating test cases that do not contribute the evaluation of the function and therefore will speed up computation time. 

\begin{minted}{haskell}
prop_positivePlusOne :: Property
prop_positivePlusOne = 
    forAll
        (choose (1, 10000))
        ((\x -> x + 1 > 0) :: Integer -> Bool)

quickCheck prop_positivePlusOne
-- OK, passed 100 tests.
\end{minted}

The "forAll" function is central to this implementation: It receives an generator and a testable function (a function that either returns bool or a property) and conducts the testing. Also note that the outer property function no longer takes any input as it generates it itself using the provided generator "choose". The result is just the same as in the previous example in the section "Conditional properties", just that it avoids generating test cases that have to be discarded.

There are many more predefined generators provided by QuickCheck. The most basic generator named "arbitrary" for example generates random values for a given type. "arbitrary :: Int" generates integers for example. If one wants to generate a fixed size list there is the "vectorOf" generator which generates a list of a given size and populates it with the values from a given generator. If one needs a list of random length the "listOf" function comes handy. Many more of those generators can be found in the QuickCheck documentation. \cite{documentation}

\subsubsection{Frequency generator}

For testing functions one usually creates test inputs that mimics the later expected real input or creates input that puts the to be tested function under maximum pressure to find bugs fast. To be able to do that one might want to define a generator statistically:

\begin{minted}{haskell}
mostlyPositive :: Gen Int
mostlyPositive =
  frequency
    [ 
        (8, choose (1, 10)),
        (1, choose (-10, -1)),
        (1, return 0)
    ]

generate (vectorOf 12 mostlyPositive) 
-- [7,10,4,10,7,4,-8,3,9,1,0,7]
\end{minted}

This example defines a generator which consists of three generators with assinged probabilities: In 80\% of the cases it is going to choose an integer between 1 and 10, with 10\% probabilitiy it will choose an integer between -10 and -1 and the 0 is choosen with also 10\% probabilitiy. This generator is therefore heighly skewd towards positive numbers but also generates negative numbers ocationally. This is achieved by using the frequency function that takes an array of tuples of the frequency and the generator. To test the generator we did not define property to use it with but instead just created some values with the function "generate".

\subsection{Shrinking}

QuickCheck provides very powerful tools to evaluate the presense of bugs with its generators and properties. A property states a logical rule, an appropriate generator creates test inputs and now we find that a property does not hold. QuickCheck informs us about the input data breaks our property. Finding the mistake in the code can be quite chellenging, espacially if the violating test case is very complex and patterns are therefore hard to find. To help the software developer to understand the bug more easily QuickCheck "shrinks" the violating test case systematically to iterativly find violating test cases that are smaller. QuickCheck shrinks the violating test case until it can not be shrunken further. This minimal violating test case is then given to the user. This method makes finding the error in the code easier after a violating test case has been discovered by QuickCheck. \cite{Claessen2009}

Shrinking consists of removing method calls and simplifying numbers in violating test cases and evaluating wehether or not the new and simpler test case still violates the property. This can be a very computational expensive endevor and is reported to take up to 80\% of the computation time. This can have quite an impact on computation time, especially when violating test cases are easy to find but hard to simplify. \cite{Hughes:2016}

\begin{minted}{haskell}
doesNotContain :: [Int] -> Bool
doesNotContain xs = 
    not ((elem 7 xs) && (elem 30 xs))

quickCheck doesNotContain
-- Failed! Falsifiable (after 93 tests and 9 shrinks):
-- [30,7]
\end{minted}

This example defines a simple test case in which it assumes that 7 and 30 can never occure in the same list. QuickCheck found a failing test case within 93 tries and then removed iterativly more and more elements from the list that made the test fail. After these 9 shrinks QuickCheck found the simplest failing test case.

\section{Commercial use}

% ERLANG ETC
% FIND RELEVANT PROJECTS

\section{QuickCheck in different languages}
%-- TODO: STATEFULL TESTING

The section "Theory" utilized exclusively Haskell to show the main ideas behind QuickCheck. This is because QuickCheck has been originally implemented in Haskell. Because of this Haskell is rooted in functional programming but its main ideas still have been translated into other languages and paradigms. As functional programming avoids uncontrolled side effects, it is known for beeing better testable. Therefore the question whether or not the ideas of QuickCheck can be applied to imperateive languages arises. This chapter is about how QuickCheck can be used in other languages.

\subsection{Java}
\subsection{Go}
\subsection{C \& C++}
\subsection{JavaScript \& Node.js}

\section{Conclusion}

% EXAMPLE SECTION
% PRACTICE SECTION

\newpage
\section{References}
\printbibliography[heading=none]

\end{document}

% CITE

%Diese Arbeit \cite{Smith:2012qr} umfasst

% SECTION

%\section{Messung der Rechenzeit einzelner Zellen}
%\subsection{CustomShell}

% PICTURE

%\begin{figure}[ht]
%    \caption{Rechenzeiten visualisiert in XSimView}
%    \centering
%    \includegraphics[width=0.8\textwidth]{messzeiten.png}
%\end{figure}

% TABLE

%\begin{tabular}{ l l }
%    outfiles.c & Filewriter f\"ur die Zeitmessung \\
%    fluxes.c & Durchf\"uhrung der Zeitmessung \\
%    cellinfo.h & Speicherung der Zeitmessung \\
%    globals.h & RecordCellCalculationTime Flag f\"ur Zeitmessung \\
%    interpreter.c & Erweiterungen des Interpreters \\
%    wrapper.c & Definition der NONE-Achse \\
%\end{tabular}
